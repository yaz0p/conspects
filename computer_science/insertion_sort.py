'''
    Сортировка вставками производит сдвиг отсортированной части массива до тех пор
    пока не выполнится условие для вставки

    Сложность: O(n^2)
    Память: O(1)
'''
def insertion_sort(arr):
    end = len(arr)
    if end <= 1:
        return arr

    for i in range(1, end):
        value = arr[i]
        index = i
        print(arr)
        while index > 0 and arr[index - 1] > value:
            arr[index] = arr[index - 1]
            index -= 1
        arr[index] = value

    return arr


if __name__ == "__main__":
    collection = [9, 10, 1, 2, 6, 4, 5, 3, 7, 8]
    print(insertion_sort(collection))

'''
Пример по итерациям:

i = 1 (value = 10):
[9, 10, 1, 2, 3, 4, 5, 6, 7, 8] (вывод).
10 сравнивается с 9 → условие 9 > 10 ложно. Вставка не требуется.

i = 2 (value = 1):
[9, 10, 1, 2, 3, 4, 5, 6, 7, 8] (вывод).
Сравниваем 1 с 10 → сдвигаем 10 вправо → [9, 10, 10, ...].
Сравниваем 1 с 9 → сдвигаем 9 вправо → [9, 9, 10, ...].
Вставляем 1 на позицию 0 → [1, 9, 10, ...].

i = 3 (value = 2):
[1, 9, 10, 2, 3, 4, 5, 6, 7, 8] (вывод).
Сравниваем 2 с 10 → сдвигаем 10 → [1, 9, 10, 10, ...].
Сравниваем 2 с 9 → сдвигаем 9 → [1, 9, 9, 10, ...].
Сравниваем 2 с 1 → вставляем 2 на позицию 1 → [1, 2, 9, 10, ...].
... и так далее для остальных элементов.

'''
