# ВВОДНАЯ ЧАСТЬ
# 
# flask - микрофреймворк. То есть он предоставляет базовый инструментарий
# для создания базовой архитектуры сайта.
# flask устанавливается на сервере, то бишь компьютере, принимающем запросы
# со стороны клиента. Например, браузер, отсылающий запросы.
#
# Flask для работы с множеством запросов использует многопоток.
# WSGI - Web Server Gateaway Interface
#
from flask import Flask

app = Flask(__name__)
"""
Создание экземпляра. Первым аргументом является имя текущего файла
Для Flask это является критичным моментом.
"""
#
# Запуск приложения Flask.
# debug=True делает возможным отображение всех возможных
# багов в консоли/браузере
#
if __name__ == "__main__":
    app.run(debug=True)
#
# Запросы обрабатываются "представлениями"
# "Представления" создаются при помощи декоратора "route"
#
@app.route("/")
def index():
    return "index"
#
# Теперь при обращении к главной странице "/" по умолчанию
# Браузер будет отрисовывать текст "index"
#
@app.route("/about")
def about():
    return "<h1>О сайте<h1>"
#
# В данном случае при попытке перейти по адресу "/about"
# сервер ответит заголовком "О сайте"
#
# При указании декораторов route подряд можно указать одно и
# то же представление для разных адресов. Например:
#
@app.route("/foo")
@app.route("/bar")
def foobar():
    return "foobar"
#
# РАБОТА С ШАБЛОНАМИ
#
# Для шаблонизации испольуется стадартный инструмент - Jinja
# Внутри Flask он вызывается следующим образом
# from flask import render_template
#
# пример использования
#
# @app.route("/")
# def foo():
#   return render_template('foo.html')
#
# Существует соглашение, что шаблоны хранятся в следующей директории:
#
# ./templates
#
# Шаблон можно наполнить при помощи следующей конструкции
#
# foo.html
#
# <h1> {{ title }} </h1>
#
# bar.py
#
# @app.route('/')
# def baz():
# return render_template('foo.html', title='foobarbaz')
#
# Теперь значение title из Flask будет передаваться в шаблон
