from typing import overload

# В python существует множество встроенных классов таких как: int, str,
# float, dict, list, set, complex, and, not, or, bool, tuple, range,
# и т.д.

# Класс-наследник может расширять или переопределять базовый класс.
# При расширении добавляются новые атрибуты, во втором - опередялются
# атрибуты с тем же именем, что и у базового класса

# Классы являются объектами.

# Все определяемые классы неявно наследуют тип `object`
class A:
    """Описание класса"""

    # Статический метод отличается от обычного метода и класса тем, что
    # не связывается ни с экземпляром, ни с классом
    # но его так же как и `classmethod` 
    # можно вызвать из класса или его экземпляра
    @staticmethod
    def validate_int(value):
        if not isinstance(value, int):
            raise TypeError(f"{value} должно быть int")

        return value

    # Внутри класса определяются атрибуты, которые могут быть как методами
    # так и полями

    # Не стоит забывать, что тело класса образует пространство имен
    # и пока мы находимся внутри класса мы можем обращаться ко всем переменным
    # и функциям определенным внутри класса без использования класса или его
    # экземпляра

    distance = validate_int(10)
    color = "white"

    # Нижнее подчеркивание "_" используется для чтобы показать, что данный атрибут
    # защищен. Фактически это никак не ограничивает доступ к данному атрибуту.
    
    _valide_colors = ["black", "red", "blue"]
    __pvt_cls = True

    # Методу класса неявно передается объект класса cls вместо self при вызове
    # из объекта класса или экземпляра класса 

    @classmethod
    def check_color(cls, color):
        return color in cls._valide_colors

    # Методы - это функции, в которые неявно передается в экземпляр класса,
    # из которого вызывался метод
    # Если метод вызывается из самого класса, то никакие аргументы неявно 
    # передаваться не будут.
    def add_color(self, name: str):
        self._valide_colors.append(name)

    # Имитация абстрактного метода. При попытке вызова выбросит исключение
    @staticmethod
    def get_food():
        raise NotImplementedError("Метод не реализован")
    
    # Двойное подчеркивание "__" используется, чтобы сделать атрибут приватным
    # Интерпритатор неявно заменит имя атрибута на _<class><attr>, чтобы мы
    # не смогли обратиться к нему вне тела класса. <class> - имя класса в,
    # в котором мы находимся. Это явление называется "манглинг"
    # Манглинг помогает защитить атрибут от переопределения в дочерних классах

    def __set_x(self):
        self.x = 1

    def set_y(self):
        self.y = 1

    # Конструктор, который создает и возвращает новый объект

    def __new__(cls,        # объект класса
                *args,      # позиционные аргументы, 
                            # переданные при создании класса
                **kwargs):   # именованные аргументы

    # __new__ можно не объявлять явно - конструктор будет взят из базового класса

        return super().__new__(cls)

    # Инициализатор, который заполняет новый объект self
    def __init__(self, color="black"):
        
    # У object он пустой - определять не обязательно

        if self.check_color(color):
        
            self.color = color

        self.__set_x() # Этот метод нельзя переопределить
        self.set_y() # А этот можно

        self.__pvt_cls = True

        # Вызов инициализатора MixinLog
        super().__init__()

        # Из инициализатора можно спокойно выбрасывать исключения, которые
        # нужно будет обработать при создании экземпляра


# Фактически, класс образует пространство имен, внутри которого мы определяем
# переменные, к которым можем обращаться
print("Доступ к содержимому класса\n")
# Доступ к пространству имено можно получить при помощи 
# магического поля __dict__
print(A.__dict__, '\n') # {'__doc__': 'Описание класса', ..., 'color': 'red'}

print("\nСоздание экземпляра класса")
a1 = A()
# Экземпляр класса имеет свой скрытый словарь, который можно заполнить
# динамически, например, в инициализаторе
# Можно обратить внимание, что экземпляр не содержит никаких магических атрибутов
# {'color': 'black', 'x': 1, 'y': 1, '_A__pvt_inst': True} black
print(a1.__dict__, a1.color)

print("\nПубличный доступ к приватному атрибуту")
# Не имеет значения принадлежит атрибут экземпляру или классу - правила
# именования одинковы во всех случаях
print(a1._A__pvt_cls, a1._A__pvt_cls) # True True 

print('\nПолучить класс объекта можно специальной функцией')

a2 = type(a1)("white")

print(a1.color)  # black

print(a2.color)  # white
# Либо при помощи магического поля (к магическим атрибутам обращаться не
# рекомендуется)

print(a1.__class__)  # <class '__main__.A'>

class MixinLog:
    def __init__(self):
        self.__counter = 0

    def save_log(self):
        self.__counter += 1
        print(f"Logger {self.__counter}")

# Круглые скобки после имени класса - это вызов __call__() из **метакласса**
# Сам класс является экземпляром метакласса, и у него своя цепочка наследования

# Класс B будет наследоваться от классов A и MixinLog
# О-принципе SOLID: нужно расширять, а не изменять

# Множественное поведение позволяет расширить поведение существуещего класса
# и нам не придется менять класс на дочерний в коде. Но для
# переопределения придется наследовать новый класс.

# При множественном наследовании используется алгоритм MRO (Method Resolution
# Order) для обхода базовых классов
# Основным родителем считается первый класс в списке - он всегда будет первым
# в цепочке базовых классов при поиске атрибута
# Остальные родительские классы считаются вспомогательными. Их называют 
# примесями: они не должны иметь своих параметров в инициализаторе, потому что
# их порядок может быть разным

class B(A, MixinLog):
    # Вложенные классы хранятся в виде объекта внутри объекта своего класса
    # Это удобно использовать для того, чтобы показать, что класс нужен для 
    # работы конкретному классу
    class Inner:
        inner_a = "a"

    __pvt_b_cls = True
    
    # Все отсутствующие локальные атрибуты будут искаться в унаследованных
    # объектах

    # Мы можем вызывать методы из суперкласса, определенные в подклассах, но
    # так делать не стоит, т.к. базовый класс не должен знать о наследниках

    # Финализатор
    # Вызывается перед удалением объекта
    def __del__(self):
        # Сборщик мусора будет вызывать этот метод, когда программа завершится

        # Не определяется пустым по умолчанию
        # super().__del__() # object has no attribute '__del__'

        print(f"\nФинализация {self}")
    
    # Реализация абстрактного метода родительского класса
    def get_food():
        print("Лазанья")

    def __init__(self):
        # super() возвращает не родителький объект, а делегатор для него

        super().__init__()
        # Можем явно вызывать родительский инициализатор, но так делать не
        # стоит, так как мы привязываемся к имени класса и можем получить цикл,
        # который разрешает MRO
        #  --> A ->
        #  |      |  ->  B -> A -> C
        #  B. <-- C      связь C -> B можем удалить, так как B уже проверили
        #A.__init__(self...)

        self.__pvt_b_inst = True

    def __set_x(self):
        self.x = 10

    def set_y(self):
        self.y = 10

b1 = B()
b2 = B()

print("\n Method Resolution Order")
# Экземпляр не имеет доступ к цепочке родителей
# b1.__mro__ # error: object has no attribute '__mro__'
# print(B.__mro__) вернет список объектов-классов, которые последовательно
# обходятся при поиске атрибута
print(B.__mro__)

B.distance = 5  # сейчас оба объекта ссылаются на один и тот же атрибут класса,
                # который мы изменили

print("Сначала мы ищем в самом объекте, а уже потом в классе и его предках")

print(b1.distance) # 5
print(b2.distance) # 5

# Мы можем назначить экземплярам собственный атрибут в инициализаторе, чтобы
# избежать такого поведения

print("\nПриватный метод не был переопределен")
print(b1.x, b1.y) # 1 10

print('\nСписок всех доступных атрибутов (включая унаследованные) можно '
      + 'получить так')
# Не все магические атрибуты наследуются
print(dir(b1))

print("\nТестируем примесь")
print(b1.save_log())

print("\nДинамическое создание атрибутов после создания объекта")
b1.phrase = 'hello, world'
# или при помощи функции
setattr(b1, 'number', 5)
# Методы также можно создавать динамически, но их нужно присваивать классу
B.print_attrs = lambda self: print(self.number, self.phrase)
b1.print_attrs() # 5, 'hello, world'
print(b1.__dict__) # {..., 'phrase': 'hello, world', 'number': 3}
# В словаре видно поле из примеси

print("\nЧтение атрибутов")
#b1.invalid  # error: object has no attribute 'invalid'
# Поиск будет выполняться и в родительских объектах
print(getattr(b1, 'distance'))  # 5
# Бросит ошибку, если не будет найден, но можем указать значение по умолчанию
print(getattr(b1, 'invalid', None))  # None
# В отличие от js, мы не теряем контекст функции, когда вызываем ее не из
# экземпляра
foo = b1.print_attrs
foo()  # 5
# getattr также возвращает функцию уже связанную с экземпляром
# <**bound** method <lambda> of <__main__.B1 object ...>>
print(getattr(b1, 'print_attrs'))

print('\nПоиск атрибута')
print(hasattr(b1, 'distance')) # True

print("\nУдаление атрибута")
# Эта операция не затрагивает родительские объекты
del b1.number
#del b1.number            # AttributeError
#delattr(b1, 'distance')  # AttributeError
# Переменная удаляется таким же образом, так как она является атрибутом
# globals()


print(('\nВстроенной функцией мы можем проверить, является ли объект '
       'экземпляром класса'))
print(isinstance(b1, B))        # True
print(isinstance(b1, A))        # True
print(isinstance(b1, object))   # True
print(isinstance(object(), B))  # False

print('\nТак можно проверить, является ли класс дочерним')
print(issubclass(B, A))       # True
print(issubclass(B, object))  # True

# Метод неявно связывается только с экземпляром, но не с объектом самого класса
# Это позволяет нам передать контекст самостоятельно
# Этот трюк можно использовать, чтобы вызывать метод из базового класса,
# который переопределяется другим базовым классом
#A.add_color('yellow')  # error: missing 1 required positional argument
A.add_color(a1, 'yellow')
print('\nНо метод класса связывается с объектом класса')
print(A.check_color('gray'))  # False
print(A.check_color('yellow'))  # True 


print('\nВложенный класс')
# У экземпляров внутреннего класса не будет поиска атрибутов во
# внешнем классе
inner = B.Inner()
print(dir(inner))
# А у экземпляра внешнего класса не будет поиска атрибутов во внутреннем
# классе
#b2.inner_a  # error: object has no attribute
# Но это можно сделать явно
print(b2.Inner.inner_a)  # a

print('\nМы можем вызывать super вне тела класса')
del b2.y
#print(b2.y)  # AttributeError
super(
    B,  # **в родителях** какого класса выполнять поиск (по умолчанию
        # self.__class__)
    b2  # контекст для вызываемых методов (по умолчанию self)
).set_y()
# Для super обязательно должно выполняться isinstance(context, class)
print(b2.y)  # 1

# Перегрузка метода выполняется при помощи декоратора @overload
# Важно, что что @overload-функции предназначены для простого объявления
# типы аргументов, не предоставляя фактической реализации. 
# Поэтому реализация должна быть предоставлена после @overload-ed
# для того, чтобы код был корректным.

@overload
def foo(bar: str) -> str:
    baz = 2 * bar
    return baz

def foo(bar: int) -> int:
    baz = 2 * bar
    return baz

print(foo(2)) # 2

print(foo('Привет мир два раза')) #Привет мир два разаПривет мир два раза
