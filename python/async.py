# Асинхронщина, зачастую, используется при I/O bound наугрузках:
# Запись/чтение, ожидание запроса и т.д. 
# По сути, данный модуль проявляет работу корутин.
# asyncio работает на генераторах
#
# Раннеры
# при запуске asyncio.run(main()) происходит обращение к контекстному
# менеджеру, контролирующему жизненный цикл цикла событий.
# Контекстный менеджер всегда создает новый event loop, позволяющий
# запускать асинхронные функции внутри. При выполнении функции происходит
# выход из контекстного менеджера. 
# 
# Корутины
# Корутины (они же подзадачи) объявляются при помощи ключевого слова
# async. Внутри корутины можно вызывать асинхронные действия при помощи
# ключевого слова await. 
#
# async def main():
#    print('hello')
#    await asyncio.sleep(1)
#    print('world')
#
# asyncio.run(main())
#
# (вывод hello world)
#
# main()
# <coroutine object main at 0x1053bb7c8> 
#
# Пример последовательного выполнения асинхронных задач. 
# Сначала выоплнится hello через 1 секунду, потом выполнится следующая.
# 
# import asyncio
# import time
# 
# async def say_after(delay, what):
#     await asyncio.sleep(delay)
#     print(what)
# 
# async def main():
#     print(f"начал в {time.strftime('%X')}")
# 
#     await say_after(1, 'hello')
#     await say_after(1, 'world')
# 
#     print(f"закончил в {time.strftime('%X')}")
# 
# asyncio.run(main())
# 
# Для одновременного выполнения нужно использовать потоконебезопасный Tasks
# Объявляются такие задачи при помощи asyncio.create_task() 
# 
# async def main():
#     task1 = asyncio.create_task(
#         say_after(1, 'hello'))
# 
#     task2 = asyncio.create_task(
#         say_after(1, 'world'))
# 
#     print(f"Начал в {time.strftime('%X')}")
# 
#     # Обе задачи выполнятся +- за 1 секунду
#     await task1
#     await task2
# 
#     print(f"Закончил в {time.strftime('%X')}")
# 
# asyncio.run(main())
#
# Более современным подходом является использование контекстного менеджера
# TaskGroup
#
# async def main():
#     async with asyncio.TaskGroup() as tg:
#         task1 = tg.create_task(
#             say_after(1, 'hello'))
# 
#         task2 = tg.create_task(
#             say_after(2, 'world'))
# 
#         print(f"начало {time.strftime('%X')}")
# 
#     # Await неявно выполнится, когда контекстный менеджер выполнит __exit__
# 
#     print(f"окончание {time.strftime('%X')}")#
#
# Существует три основных awaitable объекта: корутина, Task(Задача), Future
#
# Корутины вызываются последовательно
# Task (задачи) вызываются одновременно (не безопасно)
# Когда функция оборачивается в задачу, то планировщик задач автоматически
# планирует выполнить её ближайшее время. 
# Future - низкоуровневый объект, представляющий окончательный результат
# асинхронной операции
# Когда Future ожидается, то это означает, что корутина будет ожидать, пока
# Futute не разрешится в другом месте
# Обычно, Future не используется
#
# Дальше мне лень разбирать, т.к. такие глубокие познания мне пока что не нужны :)
