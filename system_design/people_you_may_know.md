1. Выяснение требований:

* Система нужна для расширения сети контактов и обнаружение потенциальных связей
* При поиске потенциальных знакомых концентрируемся на самых важных факторах: образовании, опыте работы и социальном контексте пользователя
* Дружба -- симметрична
* Миллиард пользователей, 300 млн. из которых ежедневно активны
* У пользователя в среднем около 1000 связей

Резюмирую требования: Требуется спроектировать систему PYMK, сходную с используемой на LinkedIn. Система принимает на вход пользователя и возвращает список потенциальных знакомых. Система разрабатывается для того, чтобы пользователям было проще находить новые связи и расширять свои сети контактов. На платформе примерно 1 миллиард пользователей, и у каждого пользователя в среднем 1000 связей.

2. Формулировка проблемы в виде задачи МО

* Цель: максимизировать количество связей между пользователями
* Определение входных и выходных данных системы: на вход подаем эмбединг пользователя, а на выход -- список подходящих пользователей
* Выбор категории МО:
 - Поточечное LTR: если мы не используем информацию о социальном контексте пользователя, то подбор кандидатов будет несколько хуже
 - Использование графов:
  - Предсказание на уровне графа. Например, если в виде графа представлено химическое соединение, можно предсказать, является ли оно ферментом.
  - Предсказание на уровне узла. Например, по графу социальной сети можно предсказать, является ли конкретный пользователь (узел) спамером.
  - Предсказание на уровне ребра. Эта задача позволяет узнать, существует ли ребро между двумя узлами. Например, по графу социальной сети можно предсказать вероятность того, что между двумя пользователями есть связь.

3. Подготовка данных

* Доступны следующие данные: пользователи; связи; взаимодействия.
* Пользователь хранит информацию о: ID, Учебное заведение, Степень, Специализация, Начало обучения, Конец обучения, Место работы, etc; нужно учиться кодировать информацию правильным образомпредложить пользователям выбирать атрибуты из заранее определенного списка; группировать разные представления атрибута с помощью эвристик; группировать похожие атрибуты с помощью методов на базе МО (например, кластеризации) или языковых моделей.
* Связи хранит информацию о: ID пользователя 1, ID пользователя 2, Временная метка создания связи
* Взаимодействия хранит информацию о: ID пользователя, Тип взаимодействия, Значение взаимодействия, Временная метка
* Конструирование признаков: 
- Признаки пользователя:
 - Демографические признаки: возраст, пол, город, страна и т. д.
 - Количество связей, подписчиков и запросов, ожидающих рассмотрения
 - Возраст учетной записи
 - Количество полученных реакций
 - Общие признаки пользователей
  - Общее место учебы или работы
  - Социальная близость

4. Разработка модели

* Выбрана архитектура графовой нейронной сети
* Обучние модели: Чтобы обучить модель GNN, мы предоставим ей моментальный снимок социального графа в момент времени t. Модель будет предсказывать связи, которые образуются к моменту времени t + 1.

5. Оценка модели:

* Оффлайн метрики:
 - ROC-AUC
 - mAP
* Онлайн метрики:
 - Общее количество заявок в друзья, отправленных за последние X дней.
 - Общее количество заявок в друзья, принятых за последние X дней.

6. Эксплуатация

* На платформе один миллиард пользователей и для каждого считать каждый раз эмбединги очень затрано, поэтому прибегают к различным хитростям: предварительный расчет, или Friends of Friends ( FoF )
* Пайплайн генерации PYMK: Этот пайплайн генерирует PYMK для всех пользователей и сохраняет результаты в базе данных; Сначала для заданного пользователя сервис FoF сужает связи до подмножества кандидатов в друзья (связей через 2 шага), Затем сервис ранжирования получает потенциальные связи, которые выработал сервис FoF, присваивает каждой из них оценку с помощью модели GNN и генерирует ранжированный список PYMK для пользователя. PYMK сохраняется в базе данных. Когда система получает запрос от пользователя, можно просто загрузить его список PYMK из базы.
* Предсказательный пайплайн: Когда поступает запрос, сервис PYMK сначала проверяет предварительно вычисленные результаты PYMK, чтобы узнать, есть ли готовые рекомендации. Если они есть, то они загружаются напрямую, а если нет, то сервис отправляет одноразовый запрос сервису генерации PYMK. 

* Оптимизация: Предварительно вычислять PYMK только для активных пользователей; Применять облегченный механизм ранжирования, чтобы сократить количество генерируемых кандидатов перед тем, как сервис ранжирования присвоит им оценки; Использовать сервис повторного ранжирования, чтобы разнообразить итоговый список PYMK
