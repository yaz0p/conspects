Система визуального поиска помогает пользователям находить изображения, визуально
похожие на выбранное пользователем изображение.
Как референс был выбран Pinterest.

1. Выяснение требований:

* Изображения должны быть отранжированы от самого похожего до наименее похожего
* Система не будет поддерживать видео
* Нужно уметь выделить фрагмент картинки, чтобы искать по фрагменту ( как в Pinterest )
* Персонализация не нужна: для одного и того же запроса будет выводиться один и тот же результат
* Метаданные изображения использоваться не будут
* В качестве меток релеватности будет использоваться клик по изображению
* Модерации не будет
* Динамическая разметка: в зависимости от действий пользователя формируется обучащая выборка
* Система должна отвечать быстро.

Резюмирую требования:

Нужно спроектировать систему для визуального поиска.
Система находит изображения, похожее на то, которое отправил пользователь, ранжирует
их по степени сходства с исходным изображением и отдает его пользователю.
Сервис работает только с графикой: не работаем с видео, аудио, текстом.
Для простоты персонализация не требуется.

2. Формулировка проблемы как задачи машинного обучения

* Цель: с высокой точностью подбирать изображения, визуально схожие с тем, что пришло системе на вход.
* Определение выходных и выходных данных: на вход подается изображение; на выходе отранжированные изображения по степени сходства
* Выходные данные модели: отранжированные картинки -- можно определить задачу как задачу ранжирования

3. Подготовка данных.

* Доступны следующие данные: изображения, пользователи, взаимодействия пользователей с изображениями
* Изображение хранит информацию о: контекстной информации, тегах, id владельца и т.д.
* Пользователь хранит информацию о: возраст, пол, местоположение и т.д.
* Информация о взаимодействии хранит информацию о: тип взаимодействия, id пользователя, id изображения, позиция изображения и т.д.
* Конструирование признаков: изменение размеров изображениия, масштабирование, нормализация Z-оценки, преобразование к единой цветовой модели.

4. Разработка модели.

* Для работы с изображениями отлично подходят сверточные нейронные сети ( ResNet, AlexNet, U-Net, etc. ) и нейронные сети с архитектурой трансформер ( ViT ).
* Для обучения подойдет подход контрастного обучения: показываем пример похожего и непохожего изображения.

* Для построения датасета для каждого  q-изображения нужно подобрать изображение, внешне похожее на на q-изображение, и n-1 изображений, не похожих на q-изображение.
 * Можно делегировать эту задачу на пользователей: если пользователь нажимает на изображение, то мы считаем, что оно похоже на q и делаем смещение весов, но тут проблема в зашумленности данных.
 * Можно использовать аугментации

* Выбор функции потерь: кросс-энтропия, потому что эмбединги должны максимально точно отражать суть изображения

5. Оценка.

* Оффлайн метрики:
 * Степень сходства будет оцениваться шкалой от 0 до 5, где 0 -- изображение не похоже на оригинал, а 5 -- два изображения визуально и семантически очень близки.
 * Для подобных задач используются следующие метрики: MRR, Precision@k, Recall@k, mAP, nDCG.
  - MRR: у MRR есть недостаток: поскольку эта метрика учитывает только первый релевантный элемент и игнорирует все остальные элементы списка, она не характеризует точность и качество ранжирования в списке
  - recall@k: эта метрика измеряет отношение количества релевантных элементов в выходном списке к общему количеству релевантных элементов во всем наборе данных.
  - precision@k: Эта метрика измеряет долю релевантных элементов среди первых k элементов выходного списка. 
  - mAP: Эта метрика сначала вычисляет среднюю точность (AP) для каждого выходного списка, а затем усредняет вычисленные значения. ( Подходит только для случая: релевантен | нерелевантен )
  - nDCG: Метрика оценивает качество ранжирования выходного списка: она показывает, насколько хорошо выполнено ранжирование по сравнению с идеальным.

* Онлайн метрики: 
 * CTR ( Click-Through Rate ) 
 * Среднее время просмотра предлагаемых изображений

6. Экплуатация.
В режиме эксплуатации система возвращает ранжированный список похожих изображений на основании исходного изображения.
* Предсказательный пайплайн:

 * Сервис генерирования эмбеддингов:
  * Сервис вычисляет эмбеддинг для исходного изображения, поступающего на вход: он выполняет предварительную обработку изображения и использует обученную модель, чтобы вычислить эмбеддинг.

 * Сервис поиска ближайшего соседа: 
  * После того как получен эмбеддинг для исходного изображения, нужно извлечь похожие изображения из пространства эмбеддингов. Этим занимается сервис поиска ближайшего соседа.

 * Сервис повторного ранжирования:
  * К этому сервису относится бизнес-логика и политики. Например, он отфильтровывает неприемлемые результаты и изображения, которые нарушают конфиденциальность, удаляет дубликаты или почти идентичные результаты и обеспечивает прочую подобную логику перед тем, как выводить окончательные результаты пользователям.

* Пайплайн индексации:
Все изображения на платформе индексируются, что повышает эффективность
поиска. Другая задача сервиса индексации — обновлять индексную таблицу. Например, когда создатель добавляет на платформу новое изображение, служба индексирует его эмбеддинг, чтобы оно обнаруживалось при поиске ближайшего соседа. Индексация повышает затраты памяти, потому что в индексной таблице сохраняются эмбеддинги целых изображений. Сократить затраты памяти позволяют различные методы оптимизации — такие, как векторное квантование и квантование по произведению (PQ, Product Quantization)
 * Эффективность алгоритмов поиска ближайшего соседа: Алгоритмы NN можно разделить на две категории: точные и приближенные.
  * У точного алгоритма сложнось O ( N * D ), где N -- количество общее количество точек, а D -- размерность точки.
  * Для приближенного поиска есть несколько реализаций, сокращающих сложность поиска точки до сублинейной, например O ( log ( N ) * D )
   * Древовидный ANN: Древовидные алгоритмы формируют дерево, разбивая пространство на несколько областей. Классические древовидные методы — R-деревья, K-d-деревья и Annoy (Approximate Nearest Neighbor Oh Yeah).
   * Хеширование, чувствительное к местоположению (LSH): Поиск на базе LSH использует специальные хеш-функции, чтобы сократить размерность точек и сгруппировать их по сегментам (бакетам).
   * ANN на основе кластеризации: Такие алгоритмы формируют кластеры, группируя точки на основании сходства. После того как кластеры образованы, алгоритм проводит поиск только среди точек в том кластере, которому принадлежит исходная точка.

8. Другие темы:
* Модерация контента: для детекции неприемлемого контента можно обучить модель для классификации непримлемого контента.
* Как использовать теги и метаданные: современные векторные базы данных умеют использовать фильтры. Соответственно, мы будем сначала фильтровать по тегам, а потом выполнять поиск.

